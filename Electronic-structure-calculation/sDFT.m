function [mol,H,X,out] = sDFT(mol,options)
% DCM Direct Constrained Minimization algorithm.
%    [mol,H,X,info] = DCM(mol,options) adopts Direct Constrained
%    Minimization algorithm to find the ground state minimum total energy
%    and the corresponding wave functions. mol is a Molecule object and
%    options is the options for running the DCM. Please read setksopt for
%    detailed information about options. DCM returns the molecule mol, the
%    Hamiltonian H, the wave functions X, and the information about
%    iteractions. If a crystal object is input instead of molecule, the
%    results will be generated by dcm4c function.
%
%   See also scf, trdcm, dcm4m, dcm4c.

%  Copyright (c) 2016-2017 Yingzhou Li and Chao Yang,
%                          Stanford University and Lawrence Berkeley
%                          National Laboratory
%  This file is distributed under the terms of the MIT License.

if (nargin < 2)
    options = setksopt();
end

opts = setksopt(); opts.eigmethod = 'eigs';


% Set timer
tstart  = cputime;

% Initialize input variables
X          = options.X0;
if isfield(options, 'H')
    H          = options.H;
end

nspin      = mol.nspin;
gtol = options.gtol;
maxit = options.maxit;
usehse = options.usehse;

% % Initialize Hamiltonian, Wavefun, and Preconditioners

% modified by Jiang
Hprec = genprec(H); 

% calculate Ewald and Ealphat
Ewald     = getEewald(mol);
Ealphat   = getEalphat(mol);

vion       = H.vion;
vext       = H.vext;

fprintf('Beging subspace calculation for %s...\n',mol.name);

% [X,~] = updateX(mol, H, X, Hprec, options);
% rho = getcharge(mol,X);
% [vhart,vxc,uxc2,rho]=getVhxc(mol,rho);
% vtot = getVtot(mol, vion, vext, vhart, vxc);
% H.vtot = vtot;
[n,p] = size(X.psi); Y1 = X;  out.nfe = 1;
for iter = 1:maxit
    % fprintf('subspace method iter %2d:\n', iter);
    
    % calculate the residual    
    [F,Ge] = fun(X,[]);  
    
    R = projection(X,Ge);
    nrmG = norm(R,'fro');
    
    out.fvec(iter) = F;
    out.nrmGvec(iter) = nrmG; 
    fprintf('iter: %4d F: %14.8e nrmG: %.2e\n',iter, F, nrmG);
    if nrmG < gtol 
        break;
    end
    
    % construct the subspace
%     y0 = X; y0.psi = orth(randn(n,2*p));
%     [y1, ~] = updateX(mol, H, y0, Hprec, opts);
    
    if usehse
        Vexxcomp = calculateACE2(VexxX, X);
        % Hf = @(X) H*X*(4/mol.nspin) + Vexxcomp(X);
        Hf = @(X) H*X*(4/mol.nspin) + Vexx2(X);
    else
        Hf = @(X) H*X;
    end
    
%     y0 = X; y0.psi = orth([X.psi, randn(n,2*p)]);
%     [y1, ~] = lobpcg(Hf, y0, Hprec, 1e-6, 200, 0);
%     Hfy = Hf(y1); yHfy = y1'*Hfy; yHfy = (yHfy + yHfy')/2;
%     res_lob = norm(Hf(y1) - y1*yHfy, 'fro');
    % fprintf('res_lob: %.2e\n', res_lob);
    
    [y1, ev] = diagbyeigs2(mol, Hf, X.idxnz, 3*p, 1e-6, 200);
    Hfy = Hf(y1); yHfy = y1'*Hfy; yHfy = (yHfy + yHfy')/2;
    res_lob = norm(Hf(y1) - y1*yHfy, 'fro');
%     fprintf('res_eigs: %.2e\n', res_lob);
    % ev'
      
    if iter == 1
%         Y = [X.psi R.psi];
        Y = [X.psi R.psi y1.psi];
    else
%         Y = [X.psi R.psi P.psi];
        Y = [X.psi R.psi P.psi y1.psi];
    end
    Y1.psi = orth(Y);
    
    % solve the projected problem
    opts_sub.xtol = 0;
    opts_sub.gtol = .1*nrmG;
    opts_sub.ftol = 0;
    opts_sub.maxit = 100;    
    
    fun_sub = @(x) fun(x,Y1);
%     n1 = size(Y1.psi,2); z = zeros(n1,p);
%     z(1:p,1:p) = eye(p);
    z = Y1.psi'*X.psi;
    
    [z, ~, out_sub] = RGBB(z, fun_sub, opts_sub);
    out.iter_sub(iter) = out_sub.iter;
    out.nfe_sub(iter) = out_sub.nfe;
    P = X; X = Y1*z;    

end

out.nrmG = nrmG;
out.fval = F;
out.iter = iter;
out.flag = 1;

timetot = cputime - tstart;

    function [F,Ge] = fun(X,Q)
        
        if ~isempty(Q)
            X = Q*X;
        end
        rho1 = getcharge(mol,X);
        % vol = get(mol,'vol');
        % Kinetic energy and some additional energy terms
        KX = applyKIEP(H,X); % not multiply with 2/nspin, hence scale it in Ekin
        Ekin = (2/mol.nspin)*iprod(X,KX);
        % Compute Hartree and exchange correlation energy and potential
        [vhart,vxc,uxc2,rho1] = getVhxc(mol,rho1);
        
        % Calculate the potential energy based on the new potential
        Ecoul = getEcoul(mol,abs(rho1),vhart);
        Exc   = getExc(mol,abs(rho1),uxc2);
        F = Ewald + Ealphat + Ekin + Ecoul + Exc;
        
        if usehse
            if ~isempty(Q)
                % Vx = Vexxcomp(X);
                % fock = 1/2*real(iprod(Vx, X));
                Vexx = getVexx(X, mol, 0);
                fock = getExx(X, Vexx, mol);
            else
                Vexx = getVexx(X, mol, 0);
                fock = getExx(X, Vexx, mol);
                
            end
            
            F = F + fock;
        else
            VexxX = [];
        end
        F = real(F);
        
        % Gradient
        vout = getVtot(mol, vion, vext, vhart, vxc);
        H.vtot = vout;
        Ge = (H*X)*(4/mol.nspin);
        if usehse
            if ~isempty(Q)
                % Ge = Ge + Vx;
                Vexx2 = @(U) Vexx(U)*(4*mol.vol^2/(mol.n1*mol.n2*mol.n3));
                VexxX = Vexx2(X);
                Ge = Ge + VexxX;
            else
                Vexx2 = @(U) Vexx(U)*(4*mol.vol^2/(mol.n1*mol.n2*mol.n3));
                VexxX = Vexx2(X);
                Ge = Ge + VexxX;
            end
        else
            VexxX = [];
        end
        
        if ~isempty(Q)
            Ge = Q'*Ge;
        end
        
    end

    function G = projection(X,G)
        % projection onto the tangent space
        GX = X'*G; GX = (GX + GX')/2;
        G  = G - X*GX;
    end

    function Vexxf = getVexx(X, mol, dfrank, exxgkk, F)
        %
        % Usage: Vexx = getVexx(X, F, exxgkk, mol)
        %
        % Purpose:
        %    Computes exact exchange operator
        %
        % Input:
        %    X  --- Wavefunction
        %    F  --- Fourier Transform
        %    dfrank --- Rank for density fitting
        %    exxgkk --- Eigenvalue of exchagne operator
        %    mol --- Molecule information
        %
        % Ouptut:
        %    Vexx --- Exact exchange operator
        %
        if nargin < 5, F = KSFFT(mol);  end
        if nargin < 4, exxgkk = getExxgkk(mol); end
        
        % n123 = mol.n1 * mol.n2 * mol.n3;
        Phi = F' * X.psi(:,logical(X.occ));
        if dfrank
            Vexxf = @(Psi)Vexxdf(Psi, Phi, dfrank, F, exxgkk, mol);
        else
            Vexxf = @(Psi)Vexx(Psi, Phi, F, exxgkk, mol);
        end
        
    end

end
